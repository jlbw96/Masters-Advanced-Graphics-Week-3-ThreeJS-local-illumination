<!DOCTYPE html>

 <html>
 <head>
     <title>Lighting and shading</title> 
           <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> 
    
           <!-- The following meta line optimizes the site for mobile devices. It sets the viewport size 
          to the screen size, so it will be displayed maximized, but unscaled. --> 
          <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"> 
		  
    <script src="js/three.min.js"></script>
	<script src="js/Detector.js"></script>
    <script src="js/OrbitControls.js"></script>
 </head>
<div id="overlaytext" style="position: absolute; top: 600px; left: 100px"> 

<body>

 <h2>Local illumination</h2>
 <p>The given code shows the modeling and visualization of a prism under different lighting and rendering conditions. 
 Try to complete the following tasks or answer the following questions and observe different visual effects generated.  
    <ol>
	 <li> First try to light the prism. What would happen if you decrease or increase the intensities of the ambient light, diffuse light, or directional light: aColor, pColor, or dColor respectively? 
	 <li> Which light would contribute to the creation of a highlight on the prism? 
	 <li> What is the color of the highlight? Explain why.
	 <li> What would you do in order to create a highlight of "yellow"?
     <li> color and vertexColor have different priorities: which one should be used to render the surface of the prism. Investigate.
	 <li> Why is it important to call the method: prismGeom.computeFaceNormals(); to calculate the face normals, when the MeshPhongMaterial is applied?
	 <li> What visual effects are generated with and without calling the method prismGeom.computeVertexNormals();?
	 <li> Can you explain why different parts of the faces show different colors?  
	 </ol>
 </p>
 </div> 
 
<div id="test"></div>

<script>

   // define global variables 
   
    var scene; 
    var camera;
    var renderer;
	var prism, controls;
    var acolor, pcolor, dcolor;
	
	initScene();
	renderScene();
	
   // construct the functions
	function initScene() {
	
                   //   renderer = new THREE.WebGLRenderer({antialias:true}); 
				   if(Detector.webgl) { 
                      renderer = new THREE.WebGLRenderer({antialias:true}); 
   
                  // If its not supported, instantiate the canvas renderer to support all non WebGL 
                  // browsers 
                  } else { 
                      renderer = new THREE.CanvasRenderer(); 
                  } 
   
				  var WIDTH  = window.innerWidth;
				  var HEIGHT = window.innerHeight;
				  
				  renderer.setClearColor(0x000000, 1);
				  renderer.setSize(WIDTH/2, HEIGHT/2);				  
				  
				  //document.body.appendChild(renderer.domElement);
				  document.getElementById("test").appendChild(renderer.domElement);
				
       // define a scene  
	scene = new THREE.Scene();

      // define a camera
	camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 1000);
	camera.position.x = 0;
	camera.position.y = 0;
	camera.position.z = 10;
	camera.lookAt(scene.position);

	scene.add(camera);

	controls=new THREE.OrbitControls(camera, renderer.domElement);
	
   // deifne light sources
    acolor=new THREE.Color(0x555555);
	pcolor=new THREE.Color(0xff0000);
	dcolor=new THREE.Color(0x0000ff);
	
	var ambientLight = new THREE.AmbientLight(acolor);
        scene.add(ambientLight);

    var light = new THREE.PointLight(pcolor, 1, 0);
        light.position.set(0, 10, 10);
        scene.add(light);

    var directionalLight = new THREE.DirectionalLight( dcolor, 1);
    directionalLight.position.set( 0, 0, 10 );
    scene.add( directionalLight );
	
    // define objects to be displayed and added to the scene
	var s;
	s=3;
	var prismGeom = new THREE.Geometry();
	prismGeom.vertices = [  // array of Vector3 giving vertex coordinates
	 new THREE.Vector3(s, 0, s), // point 0
     new THREE.Vector3(s, 0, -s), // point 1
     new THREE.Vector3(-s, 0, -s), // point 2
     new THREE.Vector3(-s, 0, s), // point 3
     new THREE.Vector3(-s, s, 0), // point 4
     new THREE.Vector3(s, s, 0) // point 5
    ];
    
   // a rectangle is represented with two triangles, whose vertices should be put in the same anti-clockwise order. 	
   prismGeom.faces = [
        new THREE.Face3( 2, 1, 0),  // base 0
        new THREE.Face3( 3, 2, 0),  // base 1
        new THREE.Face3( 5, 4, 0), // front face 2
        new THREE.Face3( 4, 3, 0), // front face 3
        new THREE.Face3( 5, 1, 4), // rear face 4
		new THREE.Face3( 4, 1, 2), // rear face 5
		new THREE.Face3( 4, 2, 3), // left side 6
		new THREE.Face3( 5, 0, 1) // right face 7
    ]; 
	
	var colors=[
   new THREE.Color(0xCCCCCC),
   new THREE.Color("green"),
   new THREE.Color("blue"),
   new THREE.Color("yellow"),
   new THREE.Color("red")
   ];
   
   prismGeom.faces[0].color = colors[0];
   prismGeom.faces[1].color = colors[0];
   prismGeom.faces[2].color = colors[1];
   prismGeom.faces[3].color = colors[1];
   prismGeom.faces[4].color = colors[2];
   prismGeom.faces[5].color = colors[2];
   prismGeom.faces[6].color = colors[3];
   prismGeom.faces[7].color = colors[4];
   
    prismGeom.computeFaceNormals(); //computer face normals
    prismGeom.computeVertexNormals(); // computer vertex normals as the averages of the face normals passing through them
   
    var prismMaterial = new THREE.MeshPhongMaterial( { 
	color: 0xffff00,
	//vertexColors:THREE.FaceColors,
	//vertexColors:THREE.VertexColors,
    } );

   prism = new THREE.Mesh( prismGeom, prismMaterial );
   prism.rotation.x=60*Math.PI/180;;
   prism.rotation.y=60*Math.PI/180;;
   
   scene.add(prism);

	}

	function renderScene() {
      renderer.render(scene, camera);
	  //prism.rotation.x += 0.01;
	 // prism.rotation.y += 0.02;
      requestAnimationFrame(renderScene);	  
	  controls.update();
	}

		</script>
		
	</body>
 </html>
